"""
tests/test_portfolio.py
─────────────────────────
HTTP-level tests for:

  POST /api/v1/portfolio/stats
  POST /api/v1/portfolio/optimize

Test strategy
-------------
- All Supabase queries are mocked via ``configure_portfolio_mock`` from
  conftest.py — no real DB connection is made.
- PyPortfolioOpt runs on synthetic price data generated by
  ``price_rows_factory`` so its deterministic output can be asserted.
- Each test class focuses on a single concern: response shape, error
  propagation, or request-body validation.

Run with::

    cd backend
    uv run pytest tests/test_portfolio.py -v
"""

import pytest

from tests.conftest import configure_portfolio_mock

# ── Helpers ───────────────────────────────────────────────────────────────────

_STATS_URL = "/api/v1/portfolio/stats"
_OPT_URL = "/api/v1/portfolio/optimize"

# Asset-row stubs — mirrors what Supabase returns for an assets lookup.
_ASSET_A = [{"id": "asset-uuid-aapl"}]
_ASSET_B = [{"id": "asset-uuid-amzn"}]
_ASSET_C = [{"id": "asset-uuid-nvda"}]


def _default_stats_body(**overrides):
    body = {"symbols": ["AAPL", "AMZN"], "interval": "1wk"}
    body.update(overrides)
    return body


def _default_opt_body(**overrides):
    body = {
        "symbols": ["AAPL", "AMZN"],
        "interval": "1wk",
        "target": "max_sharpe",
    }
    body.update(overrides)
    return body


# ── POST /api/v1/portfolio/stats ──────────────────────────────────────────────


class TestPortfolioStats:
    """Tests for the statistics endpoint response shape and error paths."""

    async def test_200_response_shape(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """Response must contain symbols, interval, individual and advanced keys."""
        rows_a = price_rows_factory(n=60, seed=1)
        rows_b = price_rows_factory(n=60, seed=2)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(_STATS_URL, json=_default_stats_body())
        assert resp.status_code == 200

        data = resp.json()
        assert data["symbols"] == ["AAPL", "AMZN"]
        assert data["interval"] == "1wk"
        assert isinstance(data["data_points_used"], dict)
        assert isinstance(data["shared_data_points"], int)
        assert isinstance(data["individual"], dict)
        assert isinstance(data["advanced"], dict)

    async def test_individual_stats_keys_present_for_each_symbol(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """Every requested symbol must appear in 'individual' with all metric keys."""
        rows_a = price_rows_factory(n=60, seed=10)
        rows_b = price_rows_factory(n=60, seed=11)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(_STATS_URL, json=_default_stats_body())
        assert resp.status_code == 200

        individual = resp.json()["individual"]
        expected_keys = {
            "avg_return", "variance", "std_deviation", "cumulative_return",
            "annualized_volatility", "sharpe_score", "max_drawdown",
            "skewness", "kurtosis", "returns_summary", "var_95", "cvar_95",
        }
        for sym in ("AAPL", "AMZN"):
            assert sym in individual
            assert expected_keys.issubset(individual[sym].keys())

    async def test_advanced_stats_keys_present(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """Advanced stats block must contain covariance, correlation, and beta."""
        rows_a = price_rows_factory(n=60, seed=20)
        rows_b = price_rows_factory(n=60, seed=21)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(_STATS_URL, json=_default_stats_body())
        assert resp.status_code == 200

        advanced = resp.json()["advanced"]
        assert "covariance_matrix" in advanced
        assert "correlation_matrix" in advanced
        assert "beta_vs_equal_weighted" in advanced

    async def test_correlation_diagonal_is_one(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """Correlation of an asset with itself must equal 1.0."""
        rows_a = price_rows_factory(n=60, seed=30)
        rows_b = price_rows_factory(n=60, seed=31)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(_STATS_URL, json=_default_stats_body())
        assert resp.status_code == 200

        corr = resp.json()["advanced"]["correlation_matrix"]
        for sym in ("AAPL", "AMZN"):
            assert abs(corr[sym][sym] - 1.0) < 1e-4

    async def test_var_95_is_negative(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """VaR at 95% represents a loss so it must be a negative number."""
        rows_a = price_rows_factory(n=60, seed=40)
        rows_b = price_rows_factory(n=60, seed=41)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(_STATS_URL, json=_default_stats_body())
        assert resp.status_code == 200

        for sym in ("AAPL", "AMZN"):
            assert resp.json()["individual"][sym]["var_95"] < 0

    async def test_max_drawdown_is_non_positive(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """Max drawdown is always 0 or negative by definition."""
        rows_a = price_rows_factory(n=60, seed=50)
        rows_b = price_rows_factory(n=60, seed=51)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(_STATS_URL, json=_default_stats_body())
        assert resp.status_code == 200

        for sym in ("AAPL", "AMZN"):
            assert resp.json()["individual"][sym]["max_drawdown"] <= 0.0

    async def test_symbols_normalised_to_uppercase(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """Lower-case input symbols must be normalised to upper-case in the response."""
        rows_a = price_rows_factory(n=60, seed=60)
        rows_b = price_rows_factory(n=60, seed=61)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(
            _STATS_URL, json={"symbols": ["aapl", "amzn"], "interval": "1wk"}
        )
        assert resp.status_code == 200
        assert resp.json()["symbols"] == ["AAPL", "AMZN"]

    async def test_404_when_symbol_not_in_db(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """Unknown symbol returns 404 without reaching the computation layer."""
        rows_b = price_rows_factory(n=60, seed=70)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[[], _ASSET_B],  # first symbol not found
            price_rows_list=[[], rows_b],
        )

        resp = await app_client.post(_STATS_URL, json=_default_stats_body())
        assert resp.status_code == 404
        assert "AAPL" in resp.json()["detail"]

    async def test_422_when_too_few_weekly_rows(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """Symbols with fewer than 52 weekly rows must be rejected with 422."""
        # Only 20 rows — below the 52-row weekly minimum.
        rows_a = price_rows_factory(n=20, seed=80)
        rows_b = price_rows_factory(n=60, seed=81)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(_STATS_URL, json=_default_stats_body())
        assert resp.status_code == 422


# ── POST /api/v1/portfolio/optimize ──────────────────────────────────────────


class TestPortfolioOptimize:
    """Tests for the optimization endpoint response shape and error paths."""

    async def test_200_weights_sum_to_one(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """Cleaned portfolio weights must sum to approximately 1.0."""
        rows_a = price_rows_factory(n=60, seed=100)
        rows_b = price_rows_factory(n=60, seed=101)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(_OPT_URL, json=_default_opt_body())
        assert resp.status_code == 200

        weights = resp.json()["weights"]
        assert abs(sum(weights.values()) - 1.0) < 1e-3

    async def test_target_echoed_in_response(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """The chosen optimization target must be returned in the response."""
        rows_a = price_rows_factory(n=60, seed=110)
        rows_b = price_rows_factory(n=60, seed=111)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(
            _OPT_URL, json=_default_opt_body(target="min_volatility")
        )
        assert resp.status_code == 200
        assert resp.json()["target"] == "min_volatility"

    async def test_weights_are_non_negative(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """PyPortfolioOpt clean_weights() must not produce negative allocations."""
        rows_a = price_rows_factory(n=60, seed=120)
        rows_b = price_rows_factory(n=60, seed=121)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        # min_volatility is always feasible regardless of price series direction.
        resp = await app_client.post(
            _OPT_URL, json=_default_opt_body(target="min_volatility")
        )
        assert resp.status_code == 200

        for w in resp.json()["weights"].values():
            assert w > 0.0, f"weight {w} is zero — per-asset bounds should prevent this"

    async def test_efficient_frontier_has_points(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """The efficient frontier list must contain at least one point."""
        rows_a = price_rows_factory(n=60, seed=130)
        rows_b = price_rows_factory(n=60, seed=131)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(_OPT_URL, json=_default_opt_body())
        assert resp.status_code == 200
        assert len(resp.json()["efficient_frontier"]) > 0

    async def test_frontier_point_keys(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """Every frontier point must have volatility, expected_return, sharpe."""
        rows_a = price_rows_factory(n=60, seed=140)
        rows_b = price_rows_factory(n=60, seed=141)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(
            _OPT_URL, json=_default_opt_body(risk_free_rate=0.0)
        )
        assert resp.status_code == 200

        for point in resp.json()["efficient_frontier"]:
            assert "volatility" in point
            assert "expected_return" in point
            assert "sharpe" in point

    async def test_performance_keys_present(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """Performance block must contain the three standard metrics."""
        rows_a = price_rows_factory(n=60, seed=150)
        rows_b = price_rows_factory(n=60, seed=151)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        # min_volatility is always feasible regardless of price series direction.
        resp = await app_client.post(
            _OPT_URL, json=_default_opt_body(target="min_volatility")
        )
        assert resp.status_code == 200

        perf = resp.json()["performance"]
        assert "expected_annual_return" in perf
        assert "annual_volatility" in perf
        assert "sharpe_ratio" in perf

    async def test_risk_metrics_keys_present(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """Risk metrics block must contain var_95, cvar_95 and max_drawdown."""
        rows_a = price_rows_factory(n=60, seed=160)
        rows_b = price_rows_factory(n=60, seed=161)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(_OPT_URL, json=_default_opt_body())
        assert resp.status_code == 200

        risk = resp.json()["risk_metrics"]
        assert "var_95" in risk
        assert "cvar_95" in risk
        assert "max_drawdown" in risk

    async def test_404_when_symbol_not_in_db(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """A single unknown symbol causes a 404 before optimization runs."""
        rows_b = price_rows_factory(n=60, seed=170)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[[], _ASSET_B],
            price_rows_list=[[], rows_b],
        )

        resp = await app_client.post(_OPT_URL, json=_default_opt_body())
        assert resp.status_code == 404

    async def test_422_when_too_few_weekly_rows(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """Optimization is blocked when a symbol has fewer than 52 weekly rows."""
        rows_a = price_rows_factory(n=10, seed=180)  # below minimum
        rows_b = price_rows_factory(n=60, seed=181)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(_OPT_URL, json=_default_opt_body())
        assert resp.status_code == 422

    async def test_min_volatility_target(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """min_volatility target resolves to 200 and echoes the target."""
        rows_a = price_rows_factory(n=60, seed=190)
        rows_b = price_rows_factory(n=60, seed=191)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(
            _OPT_URL, json=_default_opt_body(target="min_volatility")
        )
        assert resp.status_code == 200
        assert resp.json()["target"] == "min_volatility"


# ── Request-body validation ───────────────────────────────────────────────────


class TestPortfolioRequestValidation:
    """Pydantic schema validation tests — no DB calls needed."""

    async def test_422_single_symbol(self, app_client, mock_db) -> None:
        """Exactly 1 symbol is below the 2-symbol minimum."""
        resp = await app_client.post(
            _STATS_URL, json={"symbols": ["AAPL"], "interval": "1wk"}
        )
        assert resp.status_code == 422

    async def test_422_too_many_symbols(self, app_client, mock_db) -> None:
        """More than 10 symbols exceeds the max_length constraint."""
        resp = await app_client.post(
            _STATS_URL,
            json={
                "symbols": [
                    "AAPL", "AMZN", "NVDA", "MSFT", "TSLA",
                    "GOOG", "META", "NFLX", "AMD", "INTC", "QCOM",
                ],
                "interval": "1wk",
            },
        )
        assert resp.status_code == 422

    async def test_422_invalid_interval(self, app_client, mock_db) -> None:
        """Interval '1d' is not in the allowed Literal set."""
        resp = await app_client.post(
            _STATS_URL,
            json={"symbols": ["AAPL", "AMZN"], "interval": "1d"},
        )
        assert resp.status_code == 422

    async def test_422_efficient_return_without_target_return(
        self, app_client, mock_db
    ) -> None:
        """efficient_return target requires target_return to be specified."""
        resp = await app_client.post(
            _OPT_URL,
            json={
                "symbols": ["AAPL", "AMZN"],
                "interval": "1wk",
                "target": "efficient_return",
                # target_return intentionally omitted
            },
        )
        assert resp.status_code == 422

    async def test_422_efficient_risk_without_target_volatility(
        self, app_client, mock_db
    ) -> None:
        """efficient_risk target requires target_volatility to be specified."""
        resp = await app_client.post(
            _OPT_URL,
            json={
                "symbols": ["AAPL", "AMZN"],
                "interval": "1wk",
                "target": "efficient_risk",
                # target_volatility intentionally omitted
            },
        )
        assert resp.status_code == 422

    async def test_422_invalid_target(self, app_client, mock_db) -> None:
        """Unknown optimization target must be rejected by Pydantic."""
        resp = await app_client.post(
            _OPT_URL,
            json={
                "symbols": ["AAPL", "AMZN"],
                "interval": "1wk",
                "target": "magic_returns",
            },
        )
        assert resp.status_code == 422

    async def test_returns_summary_contains_last_30(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """returns_summary dict must contain 'last_30' with up to 30 entries."""
        rows_a = price_rows_factory(n=60, seed=200)
        rows_b = price_rows_factory(n=60, seed=201)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(_STATS_URL, json=_default_stats_body())
        assert resp.status_code == 200

        summary = resp.json()["individual"]["AAPL"]["returns_summary"]
        assert "last_30" in summary
        assert len(summary["last_30"]) <= 30
        assert "min" in summary
        assert "max" in summary
        assert "mean" in summary


# ── Date-filter feature ────────────────────────────────────────────────────


class TestPortfolioDateFilter:
    """Tests for the optional from_date / to_date window parameters."""

    async def test_from_date_and_to_date_echoed_in_stats_response(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """Dates passed in the request must be echoed back in the response."""
        rows_a = price_rows_factory(n=60, seed=210)
        rows_b = price_rows_factory(n=60, seed=211)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(
            _STATS_URL,
            json={
                **_default_stats_body(),
                "from_date": "2022-01-01",
                "to_date": "2024-12-31",
            },
        )
        assert resp.status_code == 200
        data = resp.json()
        assert data["from_date"] == "2022-01-01"
        assert data["to_date"] == "2024-12-31"

    async def test_from_date_and_to_date_echoed_in_optimize_response(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """Dates passed to optimize must also be echoed in the optimize response."""
        rows_a = price_rows_factory(n=60, seed=220)
        rows_b = price_rows_factory(n=60, seed=221)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(
            _OPT_URL,
            json={
                **_default_opt_body(),
                "from_date": "2021-06-01",
                "to_date": "2023-06-30",
            },
        )
        assert resp.status_code == 200
        data = resp.json()
        assert data["from_date"] == "2021-06-01"
        assert data["to_date"] == "2023-06-30"

    async def test_422_when_from_date_not_before_to_date(
        self, app_client, mock_db
    ) -> None:
        """from_date >= to_date must be rejected by the schema validator."""
        resp = await app_client.post(
            _STATS_URL,
            json={
                **_default_stats_body(),
                "from_date": "2024-01-01",
                "to_date": "2023-01-01",  # earlier than from_date
            },
        )
        assert resp.status_code == 422

    async def test_omitting_dates_returns_null_in_response(
        self, app_client, mock_db, price_rows_factory
    ) -> None:
        """When no dates are provided the response fields must be null."""
        rows_a = price_rows_factory(n=60, seed=230)
        rows_b = price_rows_factory(n=60, seed=231)
        configure_portfolio_mock(
            mock_db,
            asset_rows_list=[_ASSET_A, _ASSET_B],
            price_rows_list=[rows_a, rows_b],
        )

        resp = await app_client.post(_STATS_URL, json=_default_stats_body())
        assert resp.status_code == 200
        data = resp.json()
        assert data["from_date"] is None
        assert data["to_date"] is None
